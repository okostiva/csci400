// This file would normally be generated by Flex
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h> 

#include "calc.tab.h"

#define MAXINDEX (20)

//Global variables to track the current lexeme and character index of the lexeme
int currentIndex = 0;
char currentLexeme[MAXINDEX] = { 0 };

//Reinitialize the current lexeme and reset the character index
void newLexeme(void)
{
	int i;

	for (i = 0; i<currentIndex; i++)
		currentLexeme[i] = 0;

	currentIndex = 0;
}

//Check to see if the comment or bad characters are graphical
//	- If not, replace the characters with #nn where nn is the 2-digit hex value of the byte
//	- If so, the character can be included in the output without modification
void replaceBadChars(void)
{
	int i;
	
	//Initialize the yytext variable based on the size of the current lexeme
	//Multiply the count by 3 in case every character is bad and must be represeneted by #nn
	yytext = (char *) malloc((currentIndex*3)*sizeof(char));

	//Initialize the yytext variable with the first character of the current lexeme
	if (isgraph(currentLexeme[0])&&('#' != currentLexeme[0]))
		sprintf(yytext, "%c", currentLexeme[0]);
	else
		sprintf(yytext, "#%02X", (currentLexeme[0]&0xFF));

	//For the remainder of the characters in the current lexeme, determine if the character is graphical
	for (i=1; i<currentIndex; i++)
	{
		if (isgraph(currentLexeme[i])&&('#' != currentLexeme[i]))
			sprintf(yytext, "%s%c", yytext, currentLexeme[i]);
		else
			sprintf(yytext, "%s#%02X",  yytext, (currentLexeme[i]&0xFF));
	}
}

//A forward slash was found and could correspond to one of three possibilities:
//	1) If the next character is a forward slash, a line comment has been found
//	2) If the next character is an asterisk, a block comment has been found
int lexForwardSlash(int *lineCount)
{
	int currentChar = fgetc(yyin);
	int token;

	//Line comment found
	if (currentChar == '/')
	{
		newLexeme();
		//Get the first 20 characters, or a new line character for a line comment
		while (currentChar = fgetc(yyin))
		{
			if (currentChar == '\n')
				break;

			if (currentIndex < MAXINDEX)
			{
				if (isgraph(currentChar)&&('#' != currentChar))
					currentLexeme[currentIndex++] = currentChar;
				else
					currentLexeme[currentIndex++] = (currentChar&0xFF);
			}
		}

		token = EOLCMT;
		replaceBadChars();
		newLexeme();
		currentLexeme[currentIndex++] = currentChar;
	}
	//Block comment found
	else if (currentChar == '*')
	{
		char nextChar = fgetc(yyin);
				
		newLexeme();
		//Get the first 20 characters, or the characters */ to end the block comment
		while ((currentChar = nextChar) && (nextChar = fgetc(yyin)))
		{
			if (nextChar == '\n')
				(*lineCount)++;

			if ((currentChar == '*') && (nextChar == '/'))
				break;

			if (currentIndex < MAXINDEX)
			{
				if (isgraph(currentChar)&&('#' != currentChar))
					currentLexeme[currentIndex++] = currentChar;
				else
					currentLexeme[currentIndex++] = (currentChar&0xFF);
			}
		}

		token = BLKCMT;
		replaceBadChars();
		newLexeme();
	}
	//The subsequent character did not create a comment, so it must have been a division token
	else
	{
		token = DIV;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		newLexeme();
		currentLexeme[currentIndex++] = currentChar;
	}

	return token;
}

//The first character of and ID was found; determine if an ID exists
int lexID()
{
	int token;
	int nextChar = fgetc(yyin);

	//If the next character is a digit then an ID has been found
	if (isdigit(nextChar))
	{
		currentLexeme[currentIndex++] = nextChar;
		token = ID;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		newLexeme();
	}
	//Otherwise the first character of the ID was a bad character
	else 
	{
		token = BAD;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%c", currentLexeme);
		newLexeme();
		currentLexeme[currentIndex++] = nextChar;
	}

	return token;
}

//For use when tokenizing floats and ints; adds all numeric values to the current
//lexeme and returns the next non-numeric character
int getNextNonNumeric()
{
	int nextChar = fgetc(yyin);

	//As long as the next character from the input file is a numeric, add it to the
	//current lexeme and get the next character
	while (isdigit(nextChar))
	{
		currentLexeme[currentIndex++] = nextChar;
		nextChar = fgetc(yyin);
	}

	return nextChar;
}

//The first character of a floating point exponenet has been encountered, determine
//if there is a valid exponent
int lexExponent(int callingToken)
{
	int token;
	int tempIndex = currentIndex;
	int nextChar = getNextNonNumeric();

	//If the index has not changed, that means that this could be the start of a valid exponent
	if (currentIndex == tempIndex)
	{
		//Check to make sure that the next character starts the beginning of a signed FLT
		if ((nextChar == '-') || (nextChar == '+'))
		{
			currentLexeme[currentIndex++] = nextChar;
			tempIndex = currentIndex;
			nextChar = getNextNonNumeric();

			//Check to see if the next non-numeric character is the decimal in a floating
			//point number
			if (nextChar == '.')
			{
				//If so, get the next non-numeric character
				currentLexeme[currentIndex++] == nextChar;
				nextChar = getNextNonNumeric();
			}

			//There are numbers in the exponenet, so it is valid and the token can be exported
			if (currentIndex > tempIndex)
			{
				token = FLT;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%s", currentLexeme);
				newLexeme();
				currentLexeme[currentIndex++] = nextChar;
			}
			//There are no numbers in the exponent, so it is invalid
			else
			{
				token = BAD;
				currentLexeme[currentIndex++] = nextChar;
			}
		}
		//The exponent did not begin with a valid + or - character to indicate the
		//sign of the exponent
		else
		{
			token = BAD;
			currentLexeme[currentIndex++] = nextChar;
		}
	}
	//Otherwise use the initial token and tokenize the bad data later
	else
	{
		//Remove the bad character from the current lexeme
		char badChar = currentLexeme[currentIndex];
		currentLexeme[currentIndex--] = 0;

		token = callingToken;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		newLexeme();
		//Add the bad character and the next character to the new lexeme to be tokenized
		currentLexeme[currentIndex++] = badChar;
		currentLexeme[currentIndex++] = nextChar;
	}

	return token;
}

//A floating point value has been detected, so make sure that the floating
//point is valid and check for an exponent
int lexFloating()
{
	int token;
	int nextChar = getNextNonNumeric();

	if (str)
	{
	}
	else if (toupper(nextChar) == 'E')
	{
		currentLexeme[currentIndex++] = nextChar;
		token = lexExponent(FLT);
	}
	else
	{
		token = FLT;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		printf("Found FLT:\t%s\n", yytext);
		newLexeme();
		currentLexeme[currentIndex++] = nextChar;
	}

	return token;
}

int lexNumeric()
{
	int token;
	int nextChar = getNextNonNumeric();

	if (nextChar == '.')
	{
		currentLexeme[currentIndex++] = nextChar;
		token = lexFloating();
	}
	else if (toupper(nextChar) == 'E')
	{
		currentLexeme[currentIndex++] = nextChar;
		token = lexExponent(INT);
	}
	else
	{
		token = INT;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		printf("Found INT:\t%s\n", yytext);
		newLexeme();
		currentLexeme[currentIndex++] = nextChar;
	}

	if (token == BAD)
	{
		printf("Found BAD... Uh oh...\t%s\n", currentLexeme);
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		newLexeme();
	}

	return token;
}

int yylex(void)
{
	static int tokens = 0;
	static int lineCount = 2;

	int token;
	int yychar;
	int *lineCountReference = &lineCount;

	//There is no current lexeme, so start a new one
	if (currentIndex == 0)
	{
		yychar = fgetc(yyin); // File assumed to be open and ready
		currentLexeme[currentIndex++] = yychar;
	}
	else
	{
		yychar = currentLexeme[currentIndex-1];
	}

	if (isdigit(yychar))
	{
		token = lexNumeric();
	}
	else
	{
		switch (yychar)
		{
			//The character is a forward slash which could start a comment or be a division sign
			case '/':
				token = lexForwardSlash(lineCountReference);
				break;
			//Check to see if we create an ID with the next character
			case 'R':
				token = lexID();
				break;
			case '(':
				token = OPAREN;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found OPAREN %s\n", yytext);
				newLexeme();
				break;
			case ')':
				token = CPAREN;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found CPAREN %s\n", yytext);
				newLexeme();
				break;
			case '=':
				token = ASSIGN;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found ASSIGN %s\n", yytext);
				newLexeme();
				break;
			case '^':
				token = EXP;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found EXP %s\n", yytext);
				newLexeme();
				break;
			case '*':
				token = MUL;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found MUL %s\n", yytext);
				newLexeme();
				break;
			case '+':
				token = ADD;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found ADD %s\n", yytext);
				newLexeme();
				break;
			case '-':
				token = SUB;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found SUB %s\n", yytext);
				newLexeme();
				break;
			case ';':
				token = SEMI;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found SEMI %s\n", yytext);
				newLexeme();
				break;
			case '.':
				token = lexFloating();
				break;
			case '\n':
				token = NEWLINE;
				yytext = (char *) malloc(11*sizeof(char));
				sprintf(yytext, "%i", lineCount++);
				printf("Found NEWLINE %s\n", yytext);
				newLexeme();
				break;
			case EOF:
				token = END;
				yytext = (char *) malloc(11*sizeof(char));
				sprintf(yytext, "%i", tokens);
				printf("Found END %s\n", yytext);
				newLexeme();
				break;
			default:
				token = BAD;
				replaceBadChars();
				newLexeme();
				break;
		}
	}

	return token;
}

int main(int argc, char *argv[])
{

	if (argc <= 1)
	{
		printf("USAGE: calc inputfilename\n");
		exit(EXIT_FAILURE);
	}

	yyparse(argv[1]);

	printf("Hit ENTER to exit.");
	fgetc(stdin);

	return 0;
}
