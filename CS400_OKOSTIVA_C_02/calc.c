// This file would normally be generated by Flex
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h> 

#include "calc.tab.h"

#define MAXINDEX (20)

//Global variables to track the current lexeme and character index of the lexeme
int currentIndex = 0;
int bufferIndex = 0;
char currentLexeme[MAXINDEX] = { 0 };
char buffer[MAXINDEX] = { 0 };

char getNextChar()
{
	if (bufferIndex == 0)
		return fgetc(yyin);
	else
		return buffer[--bufferIndex];
}

//Reinitialize the current lexeme and reset the character index
void newLexeme(void)
{
	int i;

	for (i = 0; i<currentIndex; i++)
		currentLexeme[i] = 0;

	currentIndex = 0;
}

//Check to see if the comment or bad characters are graphical
//	- If not, replace the characters with #nn where nn is the 2-digit hex value of the byte
//	- If so, the character can be included in the output without modification
void replaceBadChars(void)
{
	int i;
	
	//Initialize the yytext variable based on the size of the current lexeme
	//Multiply the count by 4 in case every character is bad and must be represeneted by #nn
	//so that there is still enough space for the null terminator
	yytext = (char *) malloc((currentIndex*4)*sizeof(char));

	//Initialize the yytext variable with the first character of the current lexeme
	if (isgraph(currentLexeme[0])&&('#' != currentLexeme[0]))
		sprintf(yytext, "%c", currentLexeme[0]);
	else
		sprintf(yytext, "#%02X", (currentLexeme[0]&0xFF));

	//For the remainder of the characters in the current lexeme, determine if the character is graphical
	for (i=1; i<currentIndex; i++)
	{
		if (isgraph(currentLexeme[i])&&('#' != currentLexeme[i]))
			sprintf(yytext, "%s%c", yytext, currentLexeme[i]);
		else
			sprintf(yytext, "%s#%02X",  yytext, (currentLexeme[i]&0xFF));
	}
}

//A forward slash was found and could correspond to one of three possibilities:
//	1) If the next character is a forward slash, a line comment has been found
//	2) If the next character is an asterisk, a block comment has been found
int lexForwardSlash(int *lineCount)
{
	int currentChar = getNextChar();
	int token;

	//Line comment found
	if (currentChar == '/')
	{
		newLexeme();
		//Get the first 20 characters, or a new line character for a line comment
		while (currentChar = getNextChar())
		{
			if (currentChar == '\n')
				break;

			if (currentIndex < MAXINDEX)
			{
				if (isgraph(currentChar)&&('#' != currentChar))
					currentLexeme[currentIndex++] = currentChar;
				else
					currentLexeme[currentIndex++] = (currentChar&0xFF);
			}
		}

		buffer[bufferIndex++] = currentChar;
		token = EOLCMT;
		replaceBadChars();
		newLexeme();
	}
	//Block comment found
	else if (currentChar == '*')
	{
		char nextChar = getNextChar();
				
		newLexeme();
		//Get the first 20 characters, or the characters */ to end the block comment
		while ((currentChar = nextChar) && (nextChar = getNextChar()))
		{
			if (nextChar == '\n')
				(*lineCount)++;

			if ((currentChar == '*') && (nextChar == '/'))
				break;

			if (currentIndex < MAXINDEX)
			{
				if (isgraph(currentChar)&&('#' != currentChar))
					currentLexeme[currentIndex++] = currentChar;
				else
					currentLexeme[currentIndex++] = (currentChar&0xFF);
			}
		}

		token = BLKCMT;
		replaceBadChars();
		newLexeme();
	}
	//The subsequent character did not create a comment, so it must have been a division token
	else
	{
		buffer[bufferIndex++] = currentChar;
		token = DIV;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		newLexeme();
	}

	return token;
}

//The first character of and ID was found; determine if an ID exists
int lexID()
{
	int token;
	int nextChar = getNextChar();

	//If the next character is a digit then an ID has been found
	if (isdigit(nextChar))
	{
		currentLexeme[currentIndex++] = nextChar;
		token = ID;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		newLexeme();
	}
	//Otherwise the first character of the ID was a bad character
	else 
	{
		buffer[bufferIndex++] = nextChar;
		token = BAD;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%c", currentLexeme);
		newLexeme();
	}

	return token;
}

//For use when tokenizing floats and ints; adds all numeric values to the current
//lexeme and returns the next non-numeric character
int getNextNonNumeric()
{
	int nextChar = getNextChar();

	//As long as the next character from the input file is a numeric, add it to the
	//current lexeme and get the next character
	while (isdigit(nextChar))
	{
		currentLexeme[currentIndex++] = nextChar;
		nextChar = getNextChar();
	}

	return nextChar;
}

//The first character of a floating point exponenet has been encountered, determine
//if there is a valid exponent
int lexExponent(int callingToken)
{
	int token;
	int tempIndex = currentIndex;
	int nextChar = getNextNonNumeric();

	//If the index has not changed, the exponent may have a sign, or may start with a decimal point
	if (currentIndex == tempIndex)
	{
		//Check to make sure that the next character starts the beginning of a valid FLT
		if ((nextChar == '-') || (nextChar == '+'))
		{
			currentLexeme[currentIndex++] = nextChar;
			nextChar = getNextNonNumeric();

			//There are numbers in the exponent, so it is valid and the token can be exported
			if (currentIndex > (tempIndex + 1))
			{
				buffer[bufferIndex++] = nextChar;
				token = FLT;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%s", currentLexeme);
				newLexeme();
			}
			//There are no numbers in the exponent, so it is invalid
			else
			{
				//Remove the exponent character and the sign character and place them in the buffer
				//to be tokenized later
				buffer[bufferIndex++] = currentLexeme[currentIndex-1];
				buffer[bufferIndex++] = currentLexeme[currentIndex];
				buffer[bufferIndex++] = nextChar;
				currentLexeme[currentIndex--] = 0;
				currentLexeme[currentIndex--] = 0;

				token = callingToken;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%s", currentLexeme);
				newLexeme();
			}
		}
		//The exponent did not begin with a valid + or - character to indicate the
		//sign of the exponent
		else
		{
			//We need to remove the E and tokenize it separetely and then store the
			//next input character for tokenizing
			buffer[bufferIndex++] = currentLexeme[currentIndex];
			buffer[bufferIndex++] = nextChar;
			currentLexeme[currentIndex--] = 0;

			token = callingToken;
			yytext = (char *) malloc((currentIndex+1)*sizeof(char));
			sprintf(yytext, "%s", currentLexeme);
			newLexeme();
		}
	}
	//The E was followed by one or more numbers making a valid integer exponent
	else
	{
		buffer[bufferIndex++] = nextChar;
		token = FLT;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		newLexeme();
	}

	return token;
}

//A floating point value has been detected, so make sure that the floating
//point is valid and check for an exponent
int lexFloating()
{
	int token;
	int nextChar = getNextNonNumeric();

	//If the current lexeme does not contain at least 2 charcters then the
	//lexeme cannot be a floating point value as it must contain a decimal
	//and at least one digit
	if (currentIndex < 2)
	{
		buffer[bufferIndex++] = nextChar;
		token = BAD;
		replaceBadChars();
		newLexeme();
	}
	//This is a possible exponent
	else if (toupper(nextChar) == 'E')
	{
		currentLexeme[currentIndex++] = nextChar;
		token = lexExponent(FLT);
	}
	//Otherwise a valid floating point number has been found
	else
	{
		buffer[bufferIndex++] = nextChar;
		token = FLT;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		printf("Found FLT:\t%s\n", yytext);
		newLexeme();
	}

	return token;
}

//It is possible that either an INT or a FLT has been found so figure out which one
int lexNumeric()
{
	int token;
	int nextChar = getNextNonNumeric();

	//A decimal point has been found, so this could be a floating point number
	if (nextChar == '.')
	{
		currentLexeme[currentIndex++] = nextChar;
		token = lexFloating();
	}
	//The first character of an exponent has been found, so this could be a floating 
	//point number
	else if (toupper(nextChar) == 'E')
	{
		currentLexeme[currentIndex++] = nextChar;
		token = lexExponent(INT);
	}
	//Otherwise a valid INT has been found
	else
	{
		buffer[bufferIndex++] = nextChar;
		token = INT;
		yytext = (char *) malloc((currentIndex+1)*sizeof(char));
		sprintf(yytext, "%s", currentLexeme);
		printf("Found INT:\t%s\n", yytext);
		newLexeme();
	}

	return token;
}

int yylex(void)
{
	static int tokens = 0;
	static int lineCount = 2;

	int token;
	int yychar;
	int *lineCountReference = &lineCount;

	yychar = getNextChar(); //Function call to get the next character (may be from file or buffer)
	currentLexeme[currentIndex++] = yychar;

	//If this character is a digit, determine if this is an INT or FLT
	if (isdigit(yychar))
	{
		token = lexNumeric();
	}
	else
	{
		switch (yychar)
		{
			//The character is a forward slash which could start a comment or be a division sign
			case '/':
				token = lexForwardSlash(lineCountReference);
				break;
			//Check to see if we create an ID with the next character
			case 'R':
				token = lexID();
				break;
			case '(':
				token = OPAREN;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found OPAREN %s\n", yytext);
				newLexeme();
				break;
			case ')':
				token = CPAREN;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found CPAREN %s\n", yytext);
				newLexeme();
				break;
			case '=':
				token = ASSIGN;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found ASSIGN %s\n", yytext);
				newLexeme();
				break;
			case '^':
				token = EXP;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found EXP %s\n", yytext);
				newLexeme();
				break;
			case '*':
				token = MUL;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found MUL %s\n", yytext);
				newLexeme();
				break;
			case '+':
				token = ADD;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found ADD %s\n", yytext);
				newLexeme();
				break;
			case '-':
				token = SUB;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found SUB %s\n", yytext);
				newLexeme();
				break;
			case ';':
				token = SEMI;
				yytext = (char *) malloc((currentIndex+1)*sizeof(char));
				sprintf(yytext, "%c", yychar);
				printf("Found SEMI %s\n", yytext);
				newLexeme();
				break;
			case '.':
				token = lexFloating();
				break;
			case '\n':
				token = NEWLINE;
				yytext = (char *) malloc(11*sizeof(char));
				sprintf(yytext, "%i", lineCount++);
				printf("Found NEWLINE %s\n", yytext);
				newLexeme();
				break;
			case EOF:
				token = END;
				yytext = (char *) malloc(11*sizeof(char));
				sprintf(yytext, "%i", tokens);
				printf("Found END %s\n", yytext);
				newLexeme();
				break;
			default:
				token = BAD;
				replaceBadChars();
				newLexeme();
				break;
		}
	}

	return token;
}

int main(int argc, char *argv[])
{

	if (argc <= 1)
	{
		printf("USAGE: calc inputfilename\n");
		exit(EXIT_FAILURE);
	}

	yyparse(argv[1]);

	printf("Hit ENTER to exit.");
	fgetc(stdin);

	return 0;
}
